PART-A

1)The operators which cannot be overloaded are
i)  ?: conditional operator
ii) .  member selection
iii).* member selection with pointers
iv) :: scope resolution operator
v)  size of() operator

2) c)compiler error in line " Derived *dp = new Base;


5)catch(â€¦) is used to catch all types of exceptions arising in the program.

PART-B

6) #include<iostream.h>
   #include<conio.h>
class complex 
{
int a, b;
public:
void getvalue() 
{
cout << "Enter the value of Complex Numbers a,b:";
 cin >> a>>b;
}
complex operator+(complex ob) {
 complex t;
t.a = a + ob.a;
t.b = b + ob.b;
return (t);
}
complex operator-(complex ob) {
complex t;
t.a = a - ob.a;
t.b = b - ob.b;
 return (t);
 }
void display() {
cout << a << "+" << b << "i" << "\n";
 }
};
void main() {
clrscr();
complex obj1, obj2, result, result1;
obj1.getvalue();
obj2.getvalue();
result = obj1 + obj2;
result1 = obj1 - obj2;
cout << "Input Values:\n";
obj1.display();
obj2.display();
cout << "Result:";
result.display();
result1.display();
getch();
}
7) if derived class defines same function as defined in its base class, it is known as function overriding in C++. It is used to achieve runtime polymorphism. It enables you to provide specific implementation of the function which is already provided by its base class.
   #include <iostream>
class BaseClass {
public:
void disp(){
cout<<"Function of Parent Class";
}
};
class DerivedClass: public BaseClass{
public:
void disp() {
cout<<"Function of Child Class";
}
};
int main() {
DerivedClass obj = DerivedClass();
obj.disp();
return 0;
}

8)
